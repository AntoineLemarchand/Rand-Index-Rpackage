# 1.6
# 1.6.1
rbinom(n=1000, size=1, prob = 0.8) # une loi binomiale avec n=1000 et p=0.8
table(rbinom(n=1000, size=1, prob = 0.8)) # On les rassemble dans un tableau
table(rbinom(n=1000, size=1, prob = 0.8))/1000 # On les réduit en indice
table(rbinom(n=1000, size=1, prob = 0.8))[2]/1000 # on ne retiens que la proportion de 1
# 1.6.2
table(rbinom(n=1000, size=1, prob = 0.5))[2]/1000
# 1.6.3
i <- 0
results <- data.frame()
while (i<100) {
result <- cbind(results, table(rbinom(n=1000, size=1, prob = 0.5))/1000)
i = i + 1
}
table(rbinom(n=1000, size=1, prob = 0.8)) # On les rassemble dans un tableau
table(rbinom(n=1000, size=1, prob = 0.8))/1000 # On les réduit en indice
table(rbinom(n=1000, size=1, prob = 0.8))[2]/1000 # on ne retiens que la proportion de 1
# 1.6.2
table(rbinom(n=1000, size=1, prob = 0.5))[2]/1000
table(rbinom(n=1000, size=2, prob = 0.8))/1000 # On les réduit en indice
table(rbinom(n=1000, size=1, prob = 0.8))/1000 # On les réduit en indice
table(rbinom(n=1000, size=1, prob = 0.8))[2]/1000 # on ne retiens que la proportion de 1
# 1.6.2
nb_individus <- 1e3
pA <- 0.5
hat_PA <- rbinom(n=1,size = nb_individus,prob = pA)/nb_individus
hat_pA
hat_PA <- rbinom(n=1,size = nb_individus,prob = pA)/nb_individus
hat_pA
# 1.6.2
nb_individus <- 1e3
pA <- 0.5
hat_PA <- rbinom(n=1,size = nb_individus,prob = pA)/nb_individus
# 1.6.3
M <- 100
for(m in 1:M){
hat_PA[m] <- rbinom(n=1,
size=nb_individus,
prob=pA
) / nb_individus
}
hat_PA
mean(hat_PA)
mean(hat_PA <= 0.482)
^
for(m in 1:M){
hat_PA[m] <- rbinom(n=1,
size=nb_individus,
prob=pA
) / nb_individus
}
mean(hat_PA <= 0.482)
for(m in 1:M){
hat_PA[m] <- rbinom(n=1,
size=nb_individus,
prob=pA
) / nb_individus
}
mean(hat_PA <= 0.482)
# 1.6.2
nb_individus <- 1e3
pA <- 0.5
hat_PA <- rbinom(n=1,size = nb_individus,prob = pA)/nb_individus
# 1.6.3
M <- 100
for(m in 1:M){
hat_PA[m] <- rbinom(n=1,
size=nb_individus,
prob=pA
) / nb_individus
}
mean(hat_PA <= 0.482)
# 1.6.2
nb_individus <- 1e5
pA <- 0.5
hat_PA <- rbinom(n=1,size = nb_individus,prob = pA)/nb_individus
# 1.6.3
M <- 100
for(m in 1:M){
hat_PA[m] <- rbinom(n=1,
size=nb_individus,
prob=pA
) / nb_individus
}
mean(hat_PA <= 0.482)
# 1.6.2
nb_individus <- 1e5
pA <- 0.5
hat_PA <- rbinom(n=1,size = nb_individus,prob = pA)/nb_individus
# 1.6.3
M <- 1e4
for(m in 1:M){
hat_PA[m] <- rbinom(n=1,
size=nb_individus,
prob=pA
) / nb_individus
}
mean(hat_PA <= 0.482)
# 1.6.2
nb_individus <- 1e3
pA <- 0.5
hat_PA <- rbinom(n=1,size = nb_individus,prob = pA)/nb_individus
# 1.6.3
M <- 100
for(m in 1:M){
hat_PA[m] <- rbinom(n=1,
size=nb_individus,
prob=pA
) / nb_individus
}
mean(hat_PA <= 0.482)
mean(hat_PA <= 0.482)
prop.test(x = 482,n = nb_individus,p = 0.5,alternative = "less")
boxplot(hat_PA)
boxplot(hat_PA, ylim=c(0,1))
boxplot(hat_PA, ylim=c(0,5))
boxplot(hat_PA)
abline(0.5,)
abline(h=0.5,col="red")
boxplot(hat_PA, ylim=c(0,1))
abline(h=0.5,col="red")
boxplot(hat_PA, ylim=c(0,1))
abline(h=0.5,col="red")
abline(h=0.482,col="blue")
data("Nile")
data("Nile")
str("Nile")
plot(Nile)
boxplot(Nile)
hist(Nile)
shapiro.test(Nile)
t.test
hist(Nile)
abline(v=mean(Nile))
hist(Nile)
abline(v=mean(Nile),col="red")
t.test(Nile, alternative = "twi.sided", conf.level = 0.95)
t.test(Nile, alternative = "two.sided", conf.level = 0.95)
data("Nile")
str("Nile")
plot(Nile)
hist(Nile)
shapiro.test(Nile)
hist(Nile)
abline(v=mean(Nile),col="red")
t.test(Nile, alternative = "two.sided", conf.level = 0.95)
ggplot(Nile)
plot(Nile)
hist(Nile)
shapiro.test(Nile)
data(Nile)
plot(Nile)
library(ggplot2)
ggplot(Nile)
ggplot(c=Time, y=Nile,data=Nile)
ggplot(c=Time, y=Nile,color=red,data=Nile)
a <- ggplot(c=Time, y=Nile,color=red,data=Nile)
a
?csv2()
?csv2
?csv
a <- 0
b <- 0
c <- 0
d <- 0
n <- nrow(df)
for(i in 1:n){
for(j in 1:n){
accord1 <- (df[i, "grp1"] == df[j, "grp1"])
accord2 <- (df[i, "grp2"] == df[j, "grp2"])
a <- a + (accord1*accord2)
d <- d + (1-accord1)*(1-accord2)
b <- b + accord1 * (1-accord2)
c <- c + accord2 * (1-accord1)
}
}
RI <- (a+d)/(a+b+c+d)
RI
df
df
#' r.index
#' @param grp1 first clustering group
#' @param grp2 second clustering group
#'
#' @return A number which is the rand index
#' @export
#'
#' @examples
df
#' r.index
#' @param grp1 first clustering group
#' @param grp2 second clustering group
#'
#' @return A number which is the rand index
#' @export
#'
#' @examples
?df
library(tidyverse)
N <- rmultinom(1, 500, c(1/3, 1/3, 1/3))[,1]
plot(df)
N <- rmultinom(1, 500, c(1/3, 1/3, 1/3))[,1]
x1 <- rnorm( N[1], 0, 1)
y1 <- rnorm( N[1], 0, 2)
x2 <- rnorm( N[2], 5, 1)
y2 <- rnorm( N[2], 5, 1)
x3 <- rnorm( N[3], -3, 2)
y3 <- rnorm( N[3], 10, 1)
df <- data.frame(
x = c(x1, x2, x3),
y = c(y1, y2, y3)
plot(df)
N <- rmultinom(1, 500, c(1/3, 1/3, 1/3))[,1]
x1 <- rnorm( N[1], 0, 1)
y1 <- rnorm( N[1], 0, 2)
x2 <- rnorm( N[2], 5, 1)
y2 <- rnorm( N[2], 5, 1)
x3 <- rnorm( N[3], -3, 2)
y3 <- rnorm( N[3], 10, 1)
df <- data.frame(
x = c(x1, x2, x3),
y = c(y1, y2, y3)
)
plot(df)
HC <- hclust(dist(df), method = "single")
plot(HC)
df$grp1 <- as.factor(cutree(HC, k = 3))
ggplot(df) + aes(x = x, y = y) + geom_point(aes(color = grp1))
HC <- hclust(dist(df), method = "complete")
plot(HC)
df$grp2 <- as.factor(cutree(HC, k = 3))
ggplot(df) + aes(x = x, y = y) + geom_point(aes(color = grp2))
df
a <- 0
b <- 0
c <- 0
d <- 0
n <- nrow(df)
for(i in 1:n){
for(j in 1:n){
accord1 <- (df[i, "grp1"] == df[j, "grp1"])
accord2 <- (df[i, "grp2"] == df[j, "grp2"])
a <- a + (accord1*accord2)
d <- d + (1-accord1)*(1-accord2)
b <- b + accord1 * (1-accord2)
c <- c + accord2 * (1-accord1)
}
}
RI <- (a+d)/(a+b+c+d)
RI
#' r.index
#' @param clust1 A dataframe, first clustering group
#' @param clust2 A second dataframe the same size
#'
#' @return A number which is the rand index
#' @export
#'
#' @examples
clustering=function(dataframe,k=3){
# 1ere méthode de clustering "single"
clust <- hclust(dist(dataframe), method = "single")
dataframe$single <- as.factor(cutree(clust, k))
# 2eme méthode de clustering "complete"
clust2 <- hclust(dist(dataframe), method = "complete")
dataframe$complete <- as.factor(cutree(clust2, k))
# 3eme méthode de clustering "average"
clust3 <- hclust(dist(dataframe), method="average")
dataframe$average <- as.factor(cutree(clust3, k))
# 4eme méthode de clustering "mcquitty"
clust4 <- hclust(dist(dataframe), method="mcquitty")
dataframe$mcquitty <- as.factor(cutree(clust4, k))
# 5eme méthode de clustering "centroid"
clust5 <- hclust(dist(dataframe), method="centroid")
dataframe$centroid <- as.factor(cutree(clust5, k))
# 6eme méthode de clustering "median"
clust6 <- hclust(dist(dataframe), method="median")
dataframe$median <- as.factor(cutree(clust6, k))
# 7eme méthode de clustering "ward.D"
clust7 <- hclust(dist(dataframe), method="ward.D")
dataframe$ward.D <- as.factor(cutree(clust7, k))
# 8eme méthode de clustering "ward.D2"
clust8 <- hclust(dist(dataframe), method="ward.D2")
dataframe$ward.D2 <- as.factor(cutree(clust8, k))
return(dataframe)
}
df <- c(5,6,1,2)
clustering(df, 3)
df <- data.frame(c(5,6,1,2),c(1,2,3,4))
clustering(df, 3)
clustering(df, 1)
df <- data.frame(c(5,6,1,2),c(1,2,3,4))
clustering(df, 12)
clustering(df, 4)
r.index=function(){
n = nrow(clust)
for (method in 1:ncol(clust)) {
for (i in 1:n) {
for (j in 1:n) {
assign(paste0("accord_", method))
}
}
}
}
r.index()
r.index(Nile)
clustering(df, 4)
clustering(df, 2)
r.index=function(){
a=0
b=0
c=0
d=0
n = nrow(clust)
for (i in 1:n) {
for (j in 1:n) {
same1 <- (clust[i,2] == clust[j,2])
same2 <- (clust[i,3] == clust[j,3])
a=a+(same1*same2)
d=d+(1-same1)*(1-same2)
b=b+same1*(1-same2)
c=c+(1-same1)*same2
}
}
return ((a+d)/(a+b+c+d))
}
clustering(data.frame(c(1,2,3)),3)
df <- clustering(data.frame(c(1,2,3)),3)
r.index(df)
r.index=function(clust){
a=0
b=0
c=0
d=0
n = nrow(clust)
for (i in 1:n) {
for (j in 1:n) {
same1 <- (clust[i,2] == clust[j,2])
same2 <- (clust[i,3] == clust[j,3])
a=a+(same1*same2)
d=d+(1-same1)*(1-same2)
b=b+same1*(1-same2)
c=c+(1-same1)*same2
}
}
return ((a+d)/(a+b+c+d))
}
df <- clustering(data.frame(c(1,2,3)),3)
r.index(df)
df <- clustering(data.frame(c(1,2,3,4,5,6,2,9,8)),3)
r.index(df)
#' r.index
#' @param clust A dataframe created with clustering() or containing at least 2 groups
#' |  x  |  y  | clust1 | clust2 |
#' | --- | --- | ------ | ------ |
#' | --- | --- | ------ | ------ |
#'
#' @return A number which is the rand index
#' @export
#'
#' @examples
#' r.index
#' @param clust A dataframe created with clustering() or containing at least 2 groups
#' |  x  |  y  | clust1 | clust2 |
#' | --- | --- | ------ | ------ |
#' | --- | --- | ------ | ------ |
#'
#' @return A number which is the rand index
#' @export
#'
#' @examples
r.index=function(clust){
a=0
b=0
c=0
d=0
n = nrow(clust)
for (i in 1:n) {
for (j in 1:n) {
same1 <- (clust[i,2] == clust[j,2])
same2 <- (clust[i,3] == clust[j,3])
a=a+(same1*same2)
d=d+(1-same1)*(1-same2)
b=b+same1*(1-same2)
c=c+(1-same1)*same2
}
}
return ((a+d)/(a+b+c+d))
}
?r.index
??r.index
load_all
?r.index
install.packages(c("devtools","roxygen2","testthat",knitr))
install.packages(c("devtools","roxygen2","testthat","knitr"))
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
#' r.index
#' @param clust A dataframe created with clustering() or containing at least 2 groups
#' |  x  |  y  | clust1 | clust2 |
#' | --- | --- | ------ | ------ |
#' | --- | --- | ------ | ------ |
#'
#' @return A number which is the rand index
#' @export
#'
#' @examples
CMD build Rindex
use_mit_licence()
library(devtools)
create_package(path = ".")
create_package(path = ".")
