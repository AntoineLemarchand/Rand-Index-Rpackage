
R version 4.0.2 (2020-06-22) -- "Taking Off Again"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "Rindex"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> base::assign(".ExTimings", "Rindex-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('Rindex')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("clustering")
> ### * clustering
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: clustering
> ### Title: clustering
> ### Aliases: clustering
> ### Keywords: cluster
> 
> ### ** Examples
> 
> dataframe=norme(n=10,mu=100,sigma=5)
> clusters=clustering(dataframe, k=5)
> 
> ## plot depicting the clusters from the method "single"
> plot(clusters$x,clusters$y,col=clusters$single)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("clustering", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("hello")
> ### * hello
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: hello
> ### Title: Hello, World!
> ### Aliases: hello
> 
> ### ** Examples
> 
> hello()
[1] "Hello, world!"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("hello", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("jaccard")
> ### * jaccard
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: jaccard
> ### Title: jaccard
> ### Aliases: jaccard
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function(dataframe,method1="single",method2="complete"){
+   m11=0
+   m10=0
+   m01=0
+   n<-nrow(dataframe)
+   for (i in 1:n){
+     z=rep(dataframe[i, method1],n)
+     t=rep(dataframe[i, method2],n)
+     m11 <- m11 + sum((z==dataframe[,method1])*(t==dataframe[,method2]))
+     m10 <- m10 + sum((z==dataframe[,method1])*(1-(t==dataframe[,method2])))
+     m01 <- m01 + sum((1-(z==dataframe[,method1]))*(t==dataframe[,method2]))
+   }
+   jaccard.index=(m11)/(m11+m10+m01)
+   return(jaccard.index)
+ }
function (dataframe, method1 = "single", method2 = "complete") 
{
    m11 = 0
    m10 = 0
    m01 = 0
    n <- nrow(dataframe)
    for (i in 1:n) {
        z = rep(dataframe[i, method1], n)
        t = rep(dataframe[i, method2], n)
        m11 <- m11 + sum((z == dataframe[, method1]) * (t == 
            dataframe[, method2]))
        m10 <- m10 + sum((z == dataframe[, method1]) * (1 - (t == 
            dataframe[, method2])))
        m01 <- m01 + sum((1 - (z == dataframe[, method1])) * 
            (t == dataframe[, method2]))
    }
    jaccard.index = (m11)/(m11 + m10 + m01)
    return(jaccard.index)
}
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("jaccard", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("norme")
> ### * norme
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: norme
> ### Title: norme
> ### Aliases: norme
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function(n,mu=10,sigma=1,nb_observations=200){
+   liste_mu=list()
+   liste_sigma=list()
+   liste_lois=list()
+   liste_varx=list()
+   liste_vary=list()
+   liste_covxy=list()
+   ind_pairs=seq(1,nb_observations,2)
+   ind_impairs=seq(2,nb_observations,2)
+   x=NULL
+   y=NULL
+   for (i in 1:n){
+     liste_mu[i]=list(sample(0:mu,2,replace = TRUE))
+     liste_varx[[i]]=sample(1:sigma,1)
+     liste_vary[[i]]=sample(1:sigma,1)
+     liste_covxy[[i]]=sample(min(liste_varx[[i]],liste_vary[[i]]),1)
+     liste_sigma[i]=list(matrix(c(liste_varx[[i]],rep(liste_covxy[[i]],2),liste_vary[[i]]),2,2))
+     liste_lois[i]=list(rnorm(nb_observations,liste_mu[[i]],liste_sigma[[i]]))
+     x=c(x,liste_lois[[i]][ind_pairs])
+     y=c(y,liste_lois[[i]][ind_impairs])
+   }
+   mvr=data.frame(x,y)
+   return(mvr)
+ }
function (n, mu = 10, sigma = 1, nb_observations = 200) 
{
    liste_mu = list()
    liste_sigma = list()
    liste_lois = list()
    liste_varx = list()
    liste_vary = list()
    liste_covxy = list()
    ind_pairs = seq(1, nb_observations, 2)
    ind_impairs = seq(2, nb_observations, 2)
    x = NULL
    y = NULL
    for (i in 1:n) {
        liste_mu[i] = list(sample(0:mu, 2, replace = TRUE))
        liste_varx[[i]] = sample(1:sigma, 1)
        liste_vary[[i]] = sample(1:sigma, 1)
        liste_covxy[[i]] = sample(min(liste_varx[[i]], liste_vary[[i]]), 
            1)
        liste_sigma[i] = list(matrix(c(liste_varx[[i]], rep(liste_covxy[[i]], 
            2), liste_vary[[i]]), 2, 2))
        liste_lois[i] = list(rnorm(nb_observations, liste_mu[[i]], 
            liste_sigma[[i]]))
        x = c(x, liste_lois[[i]][ind_pairs])
        y = c(y, liste_lois[[i]][ind_impairs])
    }
    mvr = data.frame(x, y)
    return(mvr)
}
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("norme", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rand")
> ### * rand
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rand
> ### Title: rand
> ### Aliases: rand
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function(dataframe, method1="single", method2="complete"){
+   m11=0
+   m00=0
+   m10=0
+   m01=0
+   n<-nrow(dataframe)
+   for (i in 1:n){
+     z=rep(dataframe[i, method1],n)
+     t=rep(dataframe[i, method2],n)
+     m11 <- m11 + sum((z==dataframe[,method1])*(t==dataframe[,method2]))
+     m00 <- m00 + sum((1-(z==dataframe[,method1]))*(1-(t==dataframe[,method2])))
+     m10 <- m10 + sum((z==dataframe[,method1])*(1-(t==dataframe[,method2])))
+     m01 <- m01 + sum((1-(z==dataframe[,method1]))*(t==dataframe[,method2]))
+   }
+   rand.index=(m11+m00)/(m11+m00+m10+m01)
+   return(rand.index)
+ }
function (dataframe, method1 = "single", method2 = "complete") 
{
    m11 = 0
    m00 = 0
    m10 = 0
    m01 = 0
    n <- nrow(dataframe)
    for (i in 1:n) {
        z = rep(dataframe[i, method1], n)
        t = rep(dataframe[i, method2], n)
        m11 <- m11 + sum((z == dataframe[, method1]) * (t == 
            dataframe[, method2]))
        m00 <- m00 + sum((1 - (z == dataframe[, method1])) * 
            (1 - (t == dataframe[, method2])))
        m10 <- m10 + sum((z == dataframe[, method1]) * (1 - (t == 
            dataframe[, method2])))
        m01 <- m01 + sum((1 - (z == dataframe[, method1])) * 
            (t == dataframe[, method2]))
    }
    rand.index = (m11 + m00)/(m11 + m00 + m10 + m01)
    return(rand.index)
}
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rand", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.43 0.07 0.52 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
